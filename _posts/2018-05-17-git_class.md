---
layout: post
title:  git 수업 정리
categories: [git]
---

커밋을 가리키는 기능은 전부 있어(Head, tag, branch)
tag는 딱 한개의 commit만을 가지는데, 헤드는 워킹디렉토리가 어떤 스냅샷을 보여줄거냐가 의미
근데 브랜치는 작업을 나눠서 하고 싶을 때 브랜치가 어떤 커밋을 가리키고 있을때 그 남기는 커밋마다 브랜치는 이동

우리가 어떤 커밋을 만드냐에 따라 브랜치는 그 커밋을 계속 따라간다.

마스터는 운영되고 있는 코드라고 하고 새로운 코드를 만들고 싶어서 테스팅 브랜치를 만들어서 거기서 작업을 하면
계속 갈려 나가는데 이 작업에 만약 브랜치가 없고 태그를 붙여서 작업을 한다는 것은 아예 의미가 없다.
태그는 태그에 헤드를 가져다대는것이 그 자체가 불가능하다고 생각하면 된다.

물론 가능은 한데, 다음 작업을 할때 같이 이동을 한다는 것 자체가 없다.

브랜치 기준으로 푸시를 하게 된다.

브랜치 merge
작업중인 웹사이트가 잇는데, 새로운 이슈가 생겼어. 마스터 브랜치의 내용은 변경되지 않았으면 해서 브랜치를 만드는것
작업을 진행하던 중에, 작업하던 브랜치를 두고 다른 마스터 브랜치로 가서 새로운 브랜치를 만들어 작업을 한다음 그게 끝난 뒤 머지를 하고 다시 원래 작업으로 돌아오는 것

운영브랜치 이름은 보통 master(운영이름)라고 하고, 특별한건 아니고 그냥 이름이 마스터
여기에서 이제 이슈가 하나 와서 처리하고파

마스터와 이슈가 가리키고 있는 커밋이 다르다.

그러면 이슈에 있던 헤드를 체크아웃 마스터를 통해서 마스터로 헤드를 옮긴다.
그럼 그 헤드에서 새로운 브랜치를 만들고 체크아웃을 통해서 해당 브랜치로 옮긴다.

ide: 통합개발환경
우리가 어떤 코드를 작성을 하고 작성한 코드를 확인하고 실행가능한 파일로 만들어주는 역할을 예전엔 따로 했지만, 이를 한번에 해주는 것 -> 파이참 등...

이떄 새로 만든 브랜치를 마스터에 합쳐야 하는데 이 방법은 마스터 브랜치로 돌아가 새로 만든 브랜치와 합치겠다고 명령어를 주는것
합치는 것은 더 앞쪽에 있는 애들이 뒤에 이미 가버린 애들을 합치는 것이 가능

그럼 일단 체크아웃을 통해 마스터로 간 뒤 헤드가 마스터로 간 것을 확인하고
git merge hotfix(새로 만든 브랜치이름)

그러고 다시 그래프를 확인한다.
fast forward -> 앞으로 옮겼다는 것
즉 합치기 위해서는 마스터가 옮겨져 가면 되는 것.
그래서 이제 git branch -d hotfix를 통해 필요없는 브랜치를 삭제한다.

그 다음 이제 운영환경의 기존 내가 손보고 있던 브랜치로 옮겨서(체크아웃을 통해서)
다시 그 부분을 vim을 통해서 수정하고 add후 commit 한다.

근데 이게 완성 됐다고 해서 이제 master는 뒤로 가서 할 수가 없고
왜냐하면 현재 마스터가 브랜치의 조상이 아니기 때문에 커밋 두개와 공통 조상 하나가 있는 상태인데
세가지 커밋을 이용해서 하나의 컷을 만드는 즉 머지 커밋이라고 한다.

이때 일단 브랜치를 마스터로 옮기고 git merge iss53(합치려는 브랜치)하면 vim에 들어가게 되고
그 안에 들어가 커밋메시지를 남긴다.

conflict가 일어나는 이유:두 파일을 합칠 때, 너무 같은 부분이 합쳐졌다고 생각하면 충돌이 생긴다.
그러면 다시 추가를 하고 수정을 하라고 뜬다
충돌이 뜨지 않은 경우 정상적으로 머지가 됐고 그러면 필요없어진 브랜치는 삭제한다.

일반적으로는 auto merging이 될 수도 있지만 충돌이 자주 일어나기도 한다.
일부로 충돌을 일으켜보자
새로운 브랜치인 iss54를 만들고 그 안에 맨 마지막 줄에 커밋메시지를 작성하고
브랜치를 다시 마스터로 옮긴 뒤 마스터의 마지막 줄에도 커밋메시지를 남긴다.

그러면 같은 라인에 우리가 커밋 메시지를 남긴 것인데
이러는 경우 merge conflict가 일어난다.

이때 git status -> unmerged 상태로 나타나는데
그럼 vim을 통해서 해당 파일 커밋으로 들어가
오류가 난 부분을 다 삭제한다.
그러고 add후 git commit 을 수정하면 merge완료!

그 이후 필요없어진 브랜치는 다시 삭제한다.
